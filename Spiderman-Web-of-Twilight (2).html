<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spider-Man: Web of Twilight (Dev Build v5 - Full Manhattan Update)</title>
<style>
  :root {
    --red: #e62429;
    --blue: #0065bd;
    --gold: #f0b429;
    --dark: #0a0a14;
  }
  
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: var(--dark);
    font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    user-select: none;
  }
  
  canvas {
    display: block;
  }
  
  /* ‚îÄ‚îÄ UI OVERLAYS ‚îÄ‚îÄ */
  .overlay {
    position: fixed;
    inset: 0;
    z-index: 10;
    display: flex;
  }
  
  #start-screen {
    background: linear-gradient(125deg, rgba(230,36,41,.5) 0%, rgba(0,0,0,.96) 55%);
    flex-direction: column;
    justify-content: flex-end;
    padding: 80px 100px;
    color: #fff;
  }
  
  .menu-logo {
    font-size: 5.2rem;
    font-weight: 900;
    font-style: italic;
    text-transform: uppercase;
    letter-spacing: 6px;
    line-height: 1;
    text-shadow: 0 0 60px rgba(230,36,41,.9), 0 4px 20px #000;
  }
  
  .menu-sub {
    font-size: .9rem;
    letter-spacing: 10px;
    color: rgba(255,255,255,.45);
    margin: 8px 0 52px;
    text-transform: uppercase;
  }
  
  .menu-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
    font-size: 1.4rem;
    text-transform: uppercase;
    font-weight: 700;
  }
  
  .menu-item {
    cursor: pointer;
    display: flex;
    align-items: center;
    color: rgba(255,255,255,.75);
    transition: transform .15s, color .15s;
  }
  
  .menu-item:hover, .menu-item.active {
    color: var(--red);
    transform: translateX(20px);
  }
  
  .menu-item.active::before {
    content: '';
    display: inline-block;
    width: 26px;
    height: 3px;
    background: var(--red);
    margin-right: 12px;
    box-shadow: 0 0 8px var(--red);
  }
  
  #hud {
    display: none;
    z-index: 5;
    pointer-events: none;
  }
  
  .hud-tl {
    position: fixed;
    top: 26px;
    left: 26px;
  }
  
  .hp-track {
    width: 280px;
    height: 18px;
    background: rgba(0,0,0,.65);
    border: 1px solid rgba(255,255,255,.15);
    padding: 2px;
  }
  
  #health-bar {
    height: 100%;
    background: linear-gradient(90deg, #c0121a, var(--red), #ff7070);
    width: 100%;
  }
  
  .hud-stats {
    margin-top: 10px;
    font-size: .8rem;
    color: var(--gold);
    letter-spacing: 2px;
    font-weight: bold;
  }
  
  .hud-br {
    position: fixed;
    bottom: 26px;
    right: 26px;
    text-align: right;
    color: #fff;
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: flex-end;
  }
  
  .state-badge {
    font-size: .78rem;
    font-weight: 700;
    letter-spacing: 4px;
    text-transform: uppercase;
    background: rgba(0,0,0,.65);
    padding: 4px 14px;
    border-left: 3px solid var(--red);
  }
  
  .state-badge.swinging {
    border-color: var(--blue);
  }
  
  .state-badge.trick {
    border-color: var(--gold);
  }
  
  .momentum-wrap {
    width: 120px;
    height: 4px;
    background: rgba(255,255,255,.1);
    margin-top: 2px;
  }
  
  #momentum-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--blue), #44aaff);
    width: 0%;
    transition: width .08s;
  }
  
  #reticle {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 6;
  }
  
  .r-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 1.5px solid rgba(255,255,255,.4);
    transition: all .1s ease;
  }
  
  #aim-info {
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    font-size: .68rem;
    font-weight: 700;
    letter-spacing: 3px;
    color: rgba(255,255,255,.7);
    white-space: nowrap;
  }
  
  #zip-prompt {
    position: fixed;
    top: calc(50% - 56px);
    left: 50%;
    transform: translateX(-50%);
    pointer-events: none;
    z-index: 6;
    display: none;
    text-align: center;
    color: #fff;
    font-weight: 700;
    background: rgba(0,0,0,.5);
    padding: 4px 14px;
    border-radius: 3px;
  }
  
  #trick-prompt {
    position: fixed;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    color: var(--gold);
    font-weight: 900;
    font-style: italic;
    font-size: 1.2rem;
    text-shadow: 0 0 10px rgba(240,180,41,.5);
    display: none;
  }
  
  #hint {
    position: fixed;
    bottom: 18px;
    left: 18px;
    color: rgba(255,255,255,.55);
    font-size: .75rem;
    background: rgba(0,0,0,.5);
    padding: 10px 14px;
    pointer-events: none;
  }
  
  #lock-msg {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,.8);
    font-weight: 600;
    background: rgba(0,0,0,.7);
    padding: 16px 28px;
    border-radius: 8px;
    pointer-events: none;
    z-index: 6;
    display: none;
  }
  
  #pause-screen {
    display: none;
    background: rgba(0,0,0,.9);
    color: #fff;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 20;
  }
  
  #speed-overlay {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 4;
    opacity: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,30,.6) 100%);
    transition: opacity .15s;
  }
  
  #crime-alert {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(230,36,41,.8);
    color: #fff;
    padding: 8px 20px;
    font-weight: bold;
    letter-spacing: 2px;
    display: none;
    border-radius: 4px;
  }
  
  @keyframes zipFlash {
    0% { opacity: .4; }
    100% { opacity: 0; }
  }
  
  #zip-flash {
    position: fixed;
    inset: 0;
    background: #fff;
    pointer-events: none;
    z-index: 9;
    opacity: 0;
  }
  
  /* ‚îÄ‚îÄ SPEED LINES ‚îÄ‚îÄ */
  #speed-lines {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 4;
    opacity: 0;
    transition: opacity .08s;
    background: conic-gradient(from 0deg at 50% 50%,
      transparent 0deg, rgba(255,255,255,.13) 2deg, transparent 4deg,
      transparent 28deg, rgba(255,255,255,.09) 30deg, transparent 32deg,
      transparent 58deg, rgba(255,255,255,.11) 60deg, transparent 62deg,
      transparent 88deg, rgba(255,255,255,.08) 90deg, transparent 92deg,
      transparent 118deg, rgba(255,255,255,.12) 120deg, transparent 122deg,
      transparent 148deg, rgba(255,255,255,.07) 150deg, transparent 152deg,
      transparent 178deg, rgba(255,255,255,.13) 180deg, transparent 182deg,
      transparent 208deg, rgba(255,255,255,.09) 210deg, transparent 212deg,
      transparent 238deg, rgba(255,255,255,.11) 240deg, transparent 242deg,
      transparent 268deg, rgba(255,255,255,.08) 270deg, transparent 272deg,
      transparent 298deg, rgba(255,255,255,.12) 300deg, transparent 302deg,
      transparent 328deg, rgba(255,255,255,.07) 330deg, transparent 332deg
    );
    mask-image: radial-gradient(ellipse at center, transparent 18%, black 58%);
    -webkit-mask-image: radial-gradient(ellipse at center, transparent 18%, black 58%);
  }
  
  .marker {
    position: absolute;
    width: 16px;
    height: 16px;
    background: var(--red);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 10px var(--red);
    pointer-events: none;
    display: none;
    z-index: 5;
  }
</style>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>
<body>

<div id="start-screen" class="overlay">
  <div class="menu-logo">Spider-Man</div>
  <div class="menu-sub">Web of Twilight // Manhattan Update</div>
  <div class="menu-options">
    <div class="menu-item active" id="btn-newgame">Play</div>
  </div>
</div>

<div id="hud" class="overlay" style="pointer-events:none;">
  <div class="hud-tl">
    <div style="font-size:.72rem;letter-spacing:4px;font-weight:700;color:rgba(255,255,255,.6);">PETER PARKER</div>
    <div class="hp-track"><div id="health-bar"></div></div>
    <div class="hud-stats" id="collectibles-ui">BACKPACKS: 0</div>
  </div>
  <div class="hud-br">
    <div class="state-badge" id="state-badge">IDLE</div>
    <div id="speed-val" style="font-size:.72rem;color:rgba(255,255,255,.45);letter-spacing:3px;">0 mph</div>
    <div class="momentum-wrap"><div id="momentum-bar"></div></div>
  </div>
  <div id="reticle">
    <div class="r-ring" id="r-ring"></div>
    <div id="aim-info"></div>
  </div>
  <div id="zip-prompt">Q / L2+R2 &nbsp; ZIP TO POINT</div>
  <div id="trick-prompt">TRICK MASTER!</div>
  <div id="crime-alert">CRIME IN PROGRESS: <span id="crime-timer">60</span>s</div>
  <div id="crime-marker" class="marker"></div>
  <div id="hint">
    <b>WASD</b> Move &nbsp;|&nbsp; <b>Mouse/Right Stick</b> Look &nbsp;|&nbsp; <b>Space/X</b> Jump &nbsp;|&nbsp; <b>Shift/R2</b> Swing &nbsp;|&nbsp; <b>M1/Square</b> Attack<br>
    <b>G/‚ñ≥</b> Web Wings (air) &nbsp;|&nbsp; <b>C/L3</b> Dive &nbsp;|&nbsp; <b>E/‚óã</b> Wall Run &nbsp;|&nbsp; <b>R/L2+Space</b> Slingshot &nbsp;|&nbsp; <b>Q/L2+R2</b> Zip
  </div>
</div>

<div id="zip-flash"></div>
<div id="speed-overlay"></div>
<div id="speed-lines"></div>
<div id="lock-msg">üï∑ Click to start</div>
<div id="pause-screen" class="overlay"><h1>PAUSED</h1></div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

const CFG = {
  gravity:          -65,
  runAccel:         60,  
  maxGround:        35,
  airAccel:         15,  
  airFriction:      0.99,
  jumpPower:        48,
  swingRange:       400,
  springStiffness:  320,
  springDamping:    18,
  swingBoost:       50,
  swingMaxSpeed:    180, // Increased max speed slightly for better swinging
  releaseBoost:     32,
  gripMin:          0.15,
  groundBuffer:     9,
  webShortenRate:   30,
  zipSpeed:         240,
  zipGravityTime:   0.5,
  slingBoost:       55,
  cam_ground:       { offY: 1.5, offZ: -3.5, lag: 0.02, fov: 70 },
  cam_swing:        { offY: 2.0, offZ: -6.0, lag: 0.005, fov: 70 },
  cam_dive:         { offY: 0.5, offZ: -2.0, lag: 0.01, fov: 120 },
  cam_air:          { offY: 2.0, offZ: -5.0, lag: 0.015, fov: 75 },
  camFOVmax:        110,
  camLookAhead:     2.0,
  camBankMax:       0.087,
  camShakeAmp:      0.5,
  camCollisionPad:  1.0,
  wingGravityScale: 0.06,
  wingDrag:         0.992,
  wingLiftFactor:   20,
  slingshotChargeMax: 1.4,
  slingshotPower:   180,
  loopSpeedThreshold: 45,
  loopBoost:        2.0,
  loopDuration:     0.85,
  pointLaunchWindow: 0.20,
  pointLaunchBoost:  60,
  diveGravScale:    3.5,
};

const SS = Object.freeze({ 
  GROUND: 'GROUND', 
  FALL: 'FALL', 
  AIRBORNE: 'AIRBORNE', 
  SWING: 'SWING', 
  SWINGING: 'SWINGING', 
  ZIPPING: 'ZIPPING', 
  ZIP: 'ZIP', 
  TRICK: 'TRICK', 
  GLIDING: 'GLIDING', 
  DIVING: 'DIVING', 
  SLINGSHOT: 'SLINGSHOT', 
  WALLRUN: 'WALLRUN', 
  WALLCLIMB: 'WALLCLIMB' 
});

let gameState = 'MENU', scene, camera, renderer, clock, player, gameLoop;
const cityColliders = []; 
const interactables = { backpacks: [], crimes: [] };
const Keys = {};
const Input = {
  move: new THREE.Vector2(), look: new THREE.Vector2(),
  jump: false, jumpPressed: false, _prevJump: false,
  swing: false, zip: false, gripValue: 0.0,
  aim: false, attack: false, dodge: false,
  triangle: false, trick: false, gadget: false,
  webShoot: false, dive: false, scan: false,
  gpIdx: null
};

function applyDeadzone(v, dz) {
  if (Math.abs(v) < dz) return 0;
  return (v - Math.sign(v) * dz) / (1 - dz);
}

function pollInput(dt) {
  const kMoveX = (!!Keys['KeyD'] ? 1 : 0) - (!!Keys['KeyA'] ? 1 : 0);
  const kMoveY = (!!Keys['KeyS'] ? 1 : 0) - (!!Keys['KeyW'] ? 1 : 0);
  Input.move.set(kMoveX, kMoveY);
  if (Input.move.length() > 1) Input.move.normalize();

  Input._prevJump  = Input.jump;
  Input.jump       = !!(Keys['Space']);
  Input.swing      = !!(Keys['ShiftLeft'] || Keys['ShiftRight']);
  Input.zip        = !!(Keys['KeyQ']);
  Input.trick      = !!(Keys['KeyT']);
  Input.attack     = !!(Keys['KeyF'] || Keys['Mouse0']);
  Input.dodge      = !!(Keys['KeyE']);
  Input.triangle   = !!(Keys['KeyG']);
  Input.dive       = !!(Keys['KeyC']);
  Input.aim        = !!(Keys['KeyR']);
  Input.scan       = !!(Keys['KeyV']);
  Input.gadget     = !!(Keys['Tab']);
  Input.webShoot   = !!(Keys['KeyH']);
  Input.gripValue  = Input.swing ? 1.0 : 0.0;

  const GAMEPAD_DZ = 0.10;
  const allPads = navigator.getGamepads ? navigator.getGamepads() : [];
  let gp = (Input.gpIdx !== null) ? allPads[Input.gpIdx] : null;
  
  if (!gp || !gp.connected) {
    gp = null;
    for (let i = 0; i < allPads.length; i++) {
      if (allPads[i] && allPads[i].connected) { 
        gp = allPads[i]; 
        Input.gpIdx = i; 
        break; 
      }
    }
  }

  if (gp && gp.connected) {
    const lx = applyDeadzone(gp.axes[0], GAMEPAD_DZ);
    const ly = applyDeadzone(gp.axes[1], GAMEPAD_DZ);
    Input.move.set(lx, ly);
    if (Input.move.length() > 1) Input.move.normalize();

    const rx = applyDeadzone(gp.axes[2], GAMEPAD_DZ);
    const ry = applyDeadzone(gp.axes[3], GAMEPAD_DZ);
    const CAM_SENS_H = 2.8; 
    const CAM_SENS_V = 2.0;
    
    Input.look.x -= rx * CAM_SENS_H * dt;
    Input.look.y -= ry * CAM_SENS_V * dt;
    Input.look.y = Math.max(-Math.PI * 0.42, Math.min(Math.PI * 0.42, Input.look.y));

    Input._prevJump  = Input.jump;
    const btn = gp.buttons;
    const safe = (i) => btn[i] ? btn[i].pressed : false;
    const val  = (i) => btn[i] ? (btn[i].value !== undefined ? btn[i].value : (btn[i].pressed ? 1.0 : 0.0)) : 0.0;

    Input.jump      = safe(0);   
    Input.dodge     = safe(1);   
    Input.attack    = safe(2);   
    Input.triangle  = safe(3);   
    Input.gadget    = safe(4);   
    Input.webShoot  = safe(5);   
    const l2val     = val(6);
    Input.aim       = l2val > 0.1;
    Input.gripValue = val(7);
    Input.swing     = Input.gripValue > 0.1;
    Input.zip       = Input.aim && Input.swing;
    Input.dive      = safe(10); 
    Input.scan      = safe(11); 
    Input.trick     = safe(1) && safe(3);
    
    if (Input.trick) { 
      Input.dodge = false; 
      Input.triangle = false; 
    }
    if (safe(9)) togglePause(); 
  }
  Input.jumpPressed = !Input._prevJump && Input.jump;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PROCEDURAL TEXTURES ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function mkTex(w, h, draw, repeat=[1,1]) {
  const c = document.createElement('canvas'); 
  c.width = w; 
  c.height = h;
  const ctx = c.getContext('2d'); 
  draw(ctx, w, h);
  const t = new THREE.CanvasTexture(c);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  t.repeat.set(...repeat);
  return t;
}

function generateRoadTexture() {
  return mkTex(1024, 1024, (ctx, W, H) => {
    ctx.fillStyle = '#232325'; 
    ctx.fillRect(0, 0, W, H);
    for (let i = 0; i < 60000; i++) {
      const v = 28 + Math.random() * 14 | 0; 
      ctx.fillStyle = `rgb(${v},${v},${v})`;
      ctx.fillRect(Math.random() * W, Math.random() * H, 1 + Math.random() * 1.5, 1 + Math.random() * 1.5);
    }
    ctx.strokeStyle = 'rgba(0,0,0,0.35)'; 
    ctx.lineWidth = 1;
    for (let i = 0; i < 18; i++) {
      ctx.beginPath(); 
      let x = Math.random() * W, y = Math.random() * H; 
      ctx.moveTo(x, y);
      for (let s = 0; s < 6; s++) {
        x += (-20 + Math.random() * 40);
        y += (-20 + Math.random() * 40);
        ctx.lineTo(x, y);
      } 
      ctx.stroke();
    }
    ctx.fillStyle = '#c8a000'; 
    ctx.fillRect(500, 0, 7, H); 
    ctx.fillRect(517, 0, 7, H); 
    ctx.fillRect(0, 500, W, 7); 
    ctx.fillRect(0, 517, W, 7);
    
    ctx.fillStyle = 'rgba(240,240,240,0.8)';
    for (let i = 0; i < H; i += 90) { 
      ctx.fillRect(255, i, 5, 50); 
      ctx.fillRect(764, i, 5, 50); 
      ctx.fillRect(i, 255, 50, 5); 
      ctx.fillRect(i, 764, 50, 5); 
    }
    ctx.fillStyle = 'rgba(220,220,220,0.9)';
    for (let i = 0; i < H; i += 28) {
      if (i > 310 && i < 680) continue;
      ctx.fillRect(395, i, 85, 14); 
      ctx.fillRect(540, i, 85, 14); 
      ctx.fillRect(i, 395, 14, 85); 
      ctx.fillRect(i, 540, 14, 85);
    }
  }, [8, 8]);
}

function generateGlassTexture() {
  return mkTex(512, 1024, (ctx, W, H) => {
    ctx.fillStyle = '#0d1a2a'; 
    ctx.fillRect(0, 0, W, H);
    ctx.strokeStyle = '#1a3050'; 
    ctx.lineWidth = 3;
    const cols = 10, rows = 28; 
    const cw = W / cols, rh = H / rows;
    
    for (let c = 0; c <= cols; c++) {
      ctx.beginPath();
      ctx.moveTo(c * cw, 0);
      ctx.lineTo(c * cw, H);
      ctx.stroke();
    }
    for (let r = 0; r <= rows; r++) {
      ctx.beginPath();
      ctx.moveTo(0, r * rh);
      ctx.lineTo(W, r * rh);
      ctx.stroke();
    }
    for (let c = 0; c < cols; c++) {
      for (let r = 0; r < rows; r++) {
        const lit = Math.random() > 0.25;
        const warm = Math.random() > 0.5;
        if (lit) {
          const alpha = 0.5 + Math.random() * 0.5;
          ctx.fillStyle = warm ? `rgba(255,225,150,${alpha})` : `rgba(180,210,255,${alpha})`;
        } else {
          ctx.fillStyle = 'rgba(4,10,18,0.95)';
        }
        ctx.fillRect(c * cw + 3, r * rh + 3, cw - 6, rh - 6);
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(c * cw + 3, r * rh + 3, cw - 6, 3); 
        ctx.fillRect(c * cw + 3, r * rh + 3, 3, rh - 6); 
        if (lit) {
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(c * cw + 6, r * rh + 6, cw * 0.3, rh * 0.4);
        }
      }
    }
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    for (let r = 0; r < rows; r += 4) {
      ctx.fillRect(0, r * rh, W, 6);
    }
  });
}

function generateBrickTexture() {
  return mkTex(512, 512, (ctx, W, H) => {
    const bw = 48, bh = 18, mortar = 4;
    ctx.fillStyle = '#8c7a6a'; 
    ctx.fillRect(0, 0, W, H);
    const rows = Math.ceil(H / (bh + mortar));
    for (let r = 0; r < rows; r++) {
      const offset = (r % 2) * ((bw + mortar) / 2); 
      const y = r * (bh + mortar);
      const cols = Math.ceil((W + bw) / (bw + mortar));
      for (let c = 0; c < cols; c++) {
        const x = c * (bw + mortar) - offset;
        const rd = 120 + Math.random() * 60 | 0; 
        const gn = 50 + Math.random() * 30 | 0; 
        const bl = 30 + Math.random() * 25 | 0;
        ctx.fillStyle = `rgb(${rd},${gn},${bl})`; 
        ctx.fillRect(x + 2, y + 2, bw - 2, bh - 2);
        ctx.fillStyle = `rgba(255,200,160,0.15)`; 
        ctx.fillRect(x + 2, y + 2, bw - 2, 3);
        ctx.fillStyle = `rgba(0,0,0,0.25)`; 
        ctx.fillRect(x + 2, y + bh - 3, bw - 2, 3);
      }
    }
  }, [2, 4]);
}

function generateConcreteTexture() {
  return mkTex(512, 512, (ctx, W, H) => {
    ctx.fillStyle = '#6e6e72'; 
    ctx.fillRect(0, 0, W, H);
    ctx.strokeStyle = 'rgba(0,0,0,0.4)'; 
    ctx.lineWidth = 4;
    for (let x = 0; x < W; x += 64) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for (let y = 0; y < H; y += 64) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for (let i = 0; i < 8000; i++) {
      const v = 90 + Math.random() * 40 | 0; 
      ctx.fillStyle = `rgba(${v},${v},${v+5},0.4)`;
      ctx.fillRect(Math.random() * W, Math.random() * H, 2, 2);
    }
    ctx.fillStyle = 'rgba(10,15,20,0.9)';
    for (let x = 8; x < W; x += 64) {
      for (let y = 8; y < H; y += 64) {
        ctx.fillRect(x, y, 48, 48);
        ctx.fillStyle = 'rgba(255,255,255,0.05)'; 
        ctx.fillRect(x + 2, y + 2, 10, 40); 
        ctx.fillStyle = 'rgba(10,15,20,0.9)';
      }
    }
  }, [2, 4]);
}

function generateDecoTexture() {
  return mkTex(512, 512, (ctx, W, H) => {
    ctx.fillStyle = '#a0997a'; 
    ctx.fillRect(0, 0, W, H);
    ctx.strokeStyle = 'rgba(80,70,50,0.6)'; 
    ctx.lineWidth = 2;
    for (let x = 0; x < W; x += 80) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for (let y = 0; y < H; y += 40) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for (let i = 0; i < 6000; i++) {
      const v = 140 + Math.random() * 30 | 0; 
      ctx.fillStyle = `rgba(${v},${v-10},${v-25},0.3)`;
      ctx.fillRect(Math.random() * W, Math.random() * H, 2, 2);
    }
    ctx.fillStyle = 'rgba(160,145,100,0.6)'; 
    for (let y = 38; y < H; y += 40) {
      ctx.fillRect(0, y, W, 3);
    }
  }, [2, 4]);
}

function generateSidewalkTexture() {
  return mkTex(512, 512, (ctx, W, H) => {
    ctx.fillStyle = '#5a5a5c'; 
    ctx.fillRect(0, 0, W, H);
    ctx.strokeStyle = 'rgba(30,30,30,0.6)'; 
    ctx.lineWidth = 3;
    const sw = 128, sh = 96;
    for (let x = 0; x <= W; x += sw) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for (let y = 0; y <= H; y += sh) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for (let i = 0; i < 12000; i++) {
      const v = 70 + Math.random() * 35 | 0; 
      ctx.fillStyle = `rgba(${v},${v},${v},0.5)`;
      ctx.fillRect(Math.random() * W, Math.random() * H, 1, 1);
    }
    ctx.fillStyle = 'rgba(180,180,185,0.15)';
    for (let x = 0; x < W; x += sw) {
      for (let y = 0; y < H; y += sh) {
        ctx.fillRect(x + 2, y + 2, 24, 4);
      }
    }
  }, [4, 4]);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CITY GENERATION (WIDER & DETAILED) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const buildingSpawnPoints = [];

function createCity(sc) {
  const geo = new THREE.BoxGeometry(1, 1, 1);
  geo.translate(0, 0.5, 0);

  // Grey roof color
  const concreteGrey = new THREE.Color(0x4a4a4a); 
  const roofMaterial = new THREE.MeshStandardMaterial({ color: concreteGrey, roughness: 1.0 });

  const mats = {
    road: new THREE.MeshStandardMaterial({map: generateRoadTexture(), roughness: 0.92, metalness: 0.02}),
    walk: new THREE.MeshStandardMaterial({map: generateSidewalkTexture(), roughness: 0.88}),
    park: new THREE.MeshStandardMaterial({color: 0x224222, roughness: 1}),
    water: new THREE.MeshStandardMaterial({color: 0x0d2233, roughness: 0.05, metalness: 0.9, transparent: true, opacity: 0.8})
  };

  const sideTextures = {
    bldgGlass: new THREE.MeshStandardMaterial({map: generateGlassTexture(), metalness: 0.8, roughness: 0.1}),
    bldgBrick: new THREE.MeshStandardMaterial({map: generateBrickTexture(), roughness: 0.9, metalness: 0.0}),
    bldgDeco: new THREE.MeshStandardMaterial({map: generateDecoTexture(), roughness: 0.7, metalness: 0.1}),
    bldgConcrete: new THREE.MeshStandardMaterial({map: generateConcreteTexture(), roughness: 0.85, metalness: 0.05})
  };

  const getBldgMat = (sideMat) => [
    sideMat, sideMat, roofMaterial, sideMat, sideMat, sideMat
  ];

  const add = (m, x, y, z, sX, sY, sZ, coll = true) => {
    const mesh = new THREE.Mesh(geo, m);
    mesh.position.set(x, y, z);
    mesh.scale.set(sX, sY, sZ);
    mesh.castShadow = mesh.receiveShadow = true;
    sc.add(mesh);
    if (coll && sY > 1) cityColliders.push(mesh);
    return mesh;
  };

  // Ground Planes
  add(mats.water, 0, -5, 0, 15000, 4, 15000, false);
  add(mats.road, 0, 0, 0, 8000, 0.1, 10000, false);

  const matKeys = ['bldgGlass', 'bldgBrick', 'bldgDeco', 'bldgConcrete'];
  const instData = { bldgGlass: [], bldgBrick: [], bldgDeco: [], bldgConcrete: [] };
  const sidewalkData = [];
  const parkData = [];
  const parkTrees = [];
  const _dummy = new THREE.Object3D();

  // WIDER Manhattan Grid Settings ‚Äî roads widened for smooth swinging
  const aveSpacing = 440; 
  const streetSpacing = 260; 
  
  for (let x = -3000; x <= 3000; x += aveSpacing) {
    for (let z = -4000; z <= 4000; z += streetSpacing) {
      if (x === 0 && z === 0) continue;

      // Central Park Definition (Larger area, generating trees)
      if (x > -500 && x < 500 && z > -1500 && z < 1000) {
        parkData.push({x: x + (aveSpacing/2), z: z + (streetSpacing/2), sx: aveSpacing - 40, sz: streetSpacing - 20});
        
        // Populate park with trees
        for (let t = 0; t < 25; t++) {
          parkTrees.push({
             x: x + (aveSpacing/2) + (Math.random() - 0.5) * (aveSpacing - 60),
             y: 0,
             z: z + (streetSpacing/2) + (Math.random() - 0.5) * (streetSpacing - 40),
             scale: 1.5 + Math.random() * 2.5
          });
        }
        continue;
      }

      sidewalkData.push({x: x + (aveSpacing/2), z: z + (streetSpacing/2), sx: aveSpacing - 20, sz: streetSpacing - 15});

      const distFromCenter = Math.sqrt(x*x + z*z);
      const midtownFactor = Math.max(0, 1 - (distFromCenter / 4500));
      
      const key = matKeys[Math.floor(Math.random() * matKeys.length)];
      const baseH = 60 + (Math.random() * 150) + (midtownFactor * 450); 
      const bWidth = aveSpacing - 100;
      const bDepth = streetSpacing - 70;

      // MORE 3D: Multi-tiered buildings
      // Tier 1 (Base)
      instData[key].push({ x: x + (aveSpacing/2), y: 0.6, z: z + (streetSpacing/2), sx: bWidth, sy: baseH, sz: bDepth });

      let topHeight = baseH;

      // Tier 2 (Setback)
      if (baseH > 180 && Math.random() > 0.3) {
        const tier2H = 50 + Math.random() * 100;
        instData[key].push({ x: x + (aveSpacing/2), y: baseH, z: z + (streetSpacing/2), sx: bWidth * 0.75, sy: tier2H, sz: bDepth * 0.75 });
        topHeight += tier2H;
        
        // Tier 3 (Further Setback)
        if (Math.random() > 0.4) {
          const tier3H = 30 + Math.random() * 80;
          instData[key].push({ x: x + (aveSpacing/2), y: topHeight, z: z + (streetSpacing/2), sx: bWidth * 0.5, sy: tier3H, sz: bDepth * 0.5 });
          topHeight += tier3H;
          
          if (topHeight > 450) {
            // Huge Spire
            instData['bldgConcrete'].push({ x: x+(aveSpacing/2), y: topHeight, z: z+(streetSpacing/2), sx: 4, sy: 80, sz: 4 });
            buildingSpawnPoints.push(new THREE.Vector3(x+(aveSpacing/2), topHeight + 82, z+(streetSpacing/2)));
          } else {
            buildingSpawnPoints.push(new THREE.Vector3(x + (aveSpacing/2), topHeight + 2, z + (streetSpacing/2)));
          }
        } else {
          buildingSpawnPoints.push(new THREE.Vector3(x + (aveSpacing/2), topHeight + 2, z + (streetSpacing/2)));
        }
      } else {
        buildingSpawnPoints.push(new THREE.Vector3(x + (aveSpacing/2), baseH + 2, z + (streetSpacing/2)));
      }

      // Add volumetric rooftop clutter (AC units, stair hatches)
      for (let r = 0; r < 3; r++) {
        if (Math.random() > 0.4) {
           instData['bldgConcrete'].push({
              x: x + (aveSpacing/2) + (Math.random() - 0.5) * (bWidth * 0.4),
              y: topHeight,
              z: z + (streetSpacing/2) + (Math.random() - 0.5) * (bDepth * 0.4),
              sx: 6 + Math.random() * 6,
              sy: 4 + Math.random() * 5,
              sz: 6 + Math.random() * 6
           });
        }
      }

      if (topHeight > 100 && Math.random() > 0.85) {
        interactables.backpacks.push(new THREE.Vector3(x + (aveSpacing/2), topHeight + 5, z + (streetSpacing/2)));
      }
    }
  }

  // Build InstancedMeshes
  for (const key of matKeys) {
    const items = instData[key];
    if (!items.length) continue;
    
    const bldgMaterials = getBldgMat(sideTextures[key]);
    const iMesh = new THREE.InstancedMesh(geo, bldgMaterials, items.length);
    iMesh.castShadow = iMesh.receiveShadow = true;
    
    items.forEach((b, i) => {
      _dummy.position.set(b.x, b.y, b.z);
      _dummy.scale.set(b.sx, b.sy, b.sz);
      _dummy.updateMatrix();
      iMesh.setMatrixAt(i, _dummy.matrix);
    });
    
    iMesh.instanceMatrix.needsUpdate = true;
    sc.add(iMesh);
    cityColliders.push(iMesh);
  }

  // Sidewalks & Park Ground
  const spawnInstanced = (data, mat, height) => {
    const mesh = new THREE.InstancedMesh(geo, mat, data.length);
    mesh.receiveShadow = true;
    data.forEach((d, i) => {
      _dummy.position.set(d.x, 0.1, d.z);
      _dummy.scale.set(d.sx, height, d.sz);
      _dummy.updateMatrix();
      mesh.setMatrixAt(i, _dummy.matrix);
    });
    mesh.instanceMatrix.needsUpdate = true;
    sc.add(mesh);
  };

  spawnInstanced(sidewalkData, mats.walk, 0.5);
  spawnInstanced(parkData, mats.park, 0.3);

  // Render Park Trees
  if (parkTrees.length > 0) {
    const treeTrunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 4, 6);
    treeTrunkGeo.translate(0, 2, 0);
    const treeLeavesGeo = new THREE.IcosahedronGeometry(2.5, 1);
    treeLeavesGeo.translate(0, 5, 0);
    
    const trunkMat = new THREE.MeshStandardMaterial({color: 0x4a3219, roughness: 1.0});
    const leavesMat = new THREE.MeshStandardMaterial({color: 0x2b5e28, roughness: 0.9});

    const trunkMesh = new THREE.InstancedMesh(treeTrunkGeo, trunkMat, parkTrees.length);
    const leavesMesh = new THREE.InstancedMesh(treeLeavesGeo, leavesMat, parkTrees.length);
    trunkMesh.castShadow = leavesMesh.castShadow = true;

    parkTrees.forEach((t, i) => {
      _dummy.position.set(t.x, t.y, t.z);
      _dummy.scale.set(t.scale, t.scale, t.scale);
      // Give trees a random rotation
      _dummy.rotation.y = Math.random() * Math.PI * 2;
      _dummy.updateMatrix();
      trunkMesh.setMatrixAt(i, _dummy.matrix);
      leavesMesh.setMatrixAt(i, _dummy.matrix);
    });
    sc.add(trunkMesh);
    sc.add(leavesMesh);
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê NPC ENEMY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
class Enemy {
  constructor(sc, spawnPos) {
    this.sc = sc; 
    this.hp = 100; 
    this.maxHp = 100; 
    this.dead = false; 
    this.hitCooldown = 0;
    this.ragdollTimer = 0; 
    this.patrol = 0; 
    this.alertTimer = 0;
    
    this.group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({color:0x993322});
    const headMat = new THREE.MeshStandardMaterial({color:0xcc8866});
    const limbMat = new THREE.MeshStandardMaterial({color:0x772211});
    
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.5,0.7), bodyMat); 
    torso.position.y = 1.8; 
    torso.castShadow = true; 
    this.group.add(torso);
    
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), headMat); 
    head.position.y = 2.95; 
    head.castShadow = true; 
    this.group.add(head);
    
    const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.2,0.4), limbMat); 
    lArm.position.set(-0.85, 1.8, 0); 
    lArm.castShadow = true; 
    this.group.add(lArm);
    
    const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.2,0.4), limbMat); 
    rArm.position.set( 0.85, 1.8, 0); 
    rArm.castShadow = true; 
    this.group.add(rArm);
    
    const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.3,0.5), limbMat); 
    lLeg.position.set(-0.35, 0.65, 0); 
    lLeg.castShadow = true; 
    this.group.add(lLeg);
    
    const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.3,0.5), limbMat); 
    rLeg.position.set( 0.35, 0.65, 0); 
    rLeg.castShadow = true; 
    this.group.add(rLeg);
    
    this.torso = torso; 
    this.lArm = lArm; 
    this.rArm = rArm;
    
    this.group.position.copy(spawnPos); 
    this.group.position.y = spawnPos.y > 5 ? spawnPos.y : 1; 
    sc.add(this.group);
    
    this.hpEl = document.createElement('div');
    this.hpEl.style.cssText = 'position:fixed;pointer-events:none;z-index:7;width:60px;height:6px;background:#333;border:1px solid rgba(255,255,255,.3)';
    this.hpFill = document.createElement('div'); 
    this.hpFill.style.cssText = 'height:100%;background:#e62429;transition:width .1s';
    this.hpEl.appendChild(this.hpFill); 
    document.body.appendChild(this.hpEl);
  }
  
  takeHit(dmg, knockDir) {
    if (this.dead || this.hitCooldown > 0) return false;
    this.hp -= dmg; 
    this.hitCooldown = 0.15;
    
    this.group.traverse(c => { 
      if (c.isMesh) { 
        c._origColor = c.material.color.getHex(); 
        c.material = c.material.clone(); 
        c.material.color.setHex(0xff4444); 
      }
    });
    
    setTimeout(() => { 
      this.group.traverse(c => { 
        if (c.isMesh && c._origColor !== undefined) 
          c.material.color.setHex(c._origColor);
      });
    }, 120);
    
    if (knockDir) { 
      this.group.position.addScaledVector(knockDir, 3.5); 
      this.ragdollTimer = 0.4; 
    }
    
    if (this.hp <= 0) { 
      this.die(); 
    } 
    return true;
  }
  
  die() {
    this.dead = true; 
    this.group.rotation.x = Math.PI * 0.5; 
    this.group.position.y = 0.3; 
    this.hpEl.style.display = 'none';
    setTimeout(() => { 
      this.sc.remove(this.group); 
      this.hpEl.remove(); 
    }, 3000);
  }
  
  update(dt, playerPos, camera) {
    if (this.dead) return;
    this.hitCooldown = Math.max(0, this.hitCooldown - dt);
    
    const t = performance.now() * 0.002;
    this.lArm.rotation.x =  Math.sin(t + this.patrol) * 0.4; 
    this.rArm.rotation.x = -Math.sin(t + this.patrol) * 0.4;
    
    if (this.ragdollTimer > 0) { 
      this.ragdollTimer -= dt; 
    } else {
      const dist = this.group.position.distanceTo(playerPos);
      if (dist < 30) {
        this.alertTimer += dt;
        const dir = new THREE.Vector3().subVectors(playerPos, this.group.position); 
        dir.y = 0;
        if (dir.lengthSq() > 0.01) this.group.rotation.y = Math.atan2(dir.x, dir.z);
        if (dist > 5) { 
          dir.normalize(); 
          this.group.position.addScaledVector(dir, 4 * dt); 
        }
      } else {
        this.patrol += dt * 0.3; 
        this.group.rotation.y = this.patrol;
        this.group.position.x += Math.sin(this.patrol) * 2 * dt; 
        this.group.position.z += Math.cos(this.patrol) * 2 * dt;
      }
    }
    
    const screenPos = this.group.position.clone().add(new THREE.Vector3(0,4,0)).project(camera);
    if (screenPos.z < 1 && screenPos.z > -1) {
      this.hpEl.style.left = ((screenPos.x * 0.5 + 0.5) * window.innerWidth - 30) + 'px';
      this.hpEl.style.top = ((1 - (screenPos.y * 0.5 + 0.5)) * window.innerHeight - 3) + 'px';
      this.hpEl.style.display = 'block';
    } else { 
      this.hpEl.style.display = 'none'; 
    }
    
    this.hpFill.style.width = Math.max(0, this.hp / this.maxHp * 100) + '%';
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COMBAT SYSTEM ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const Combat = {
  attackCooldown: 0, _prevAttack: false, comboCount: 0, comboTimer: 0, comboEl: null,
  
  init() {
    this.comboEl = document.createElement('div');
    this.comboEl.style.cssText = 'position:fixed;right:26px;bottom:80px;color:#f0b429;font-size:2rem;font-weight:900;font-style:italic;text-shadow:0 0 20px rgba(240,180,41,.7);pointer-events:none;opacity:0;transition:opacity .3s;';
    document.body.appendChild(this.comboEl);
  },
  
  update(dt, playerPos, vel, enemies) {
    this.attackCooldown = Math.max(0, this.attackCooldown - dt);
    this.comboTimer = Math.max(0, this.comboTimer - dt);
    if (this.comboTimer <= 0 && this.comboCount > 0) { 
      this.comboCount = 0; 
      this.comboEl.style.opacity = '0'; 
    }
    
    const attackEdge = Input.attack && !this._prevAttack; 
    this._prevAttack = Input.attack;
    
    if (attackEdge && this.attackCooldown <= 0) {
      this.attackCooldown = 0.32;
      const camDir = new THREE.Vector3(); 
      camera.getWorldDirection(camDir); 
      camDir.y = 0; 
      camDir.normalize();
      
      let hitSomething = false;
      for (const e of enemies) {
        if (e.dead) continue;
        if (e.group.position.distanceTo(playerPos) < 8) {
          if (e.takeHit(25 + Math.random() * 10 | 0, camDir)) { 
            hitSomething = true; 
            this.comboCount++; 
            this.comboTimer = 2.5; 
            this._showHitFX(e.group.position.clone().add(new THREE.Vector3(0,2,0))); 
          }
        }
      }
      
      if (hitSomething) {
        const fl = document.getElementById('zip-flash'); 
        fl.style.background = '#f80'; 
        fl.style.opacity = 0.08;
        setTimeout(() => { fl.style.opacity = 0; fl.style.background = '#fff'; }, 80);
        this.comboEl.textContent = this.comboCount > 1 ? this.comboCount + 'x COMBO!' : 'HIT!';
        this.comboEl.style.opacity = '1'; 
        this.comboEl.style.fontSize = Math.min(1.5 + this.comboCount * 0.08, 3) + 'rem';
        // Trigger attack animation on the player
        if (player && player.anim) { player.anim.currentName = ''; player.anim.play('attack', 0.08); }
      }
    }
  },
  
  _showHitFX(pos) {
    const el = document.createElement('div');
    const words = ['POW!','THWAK!','SMASH!','KA-POW!']; 
    el.textContent = words[Math.floor(Math.random() * words.length)];
    el.style.cssText = 'position:fixed;pointer-events:none;font-size:1.8rem;font-weight:900;font-style:italic;color:#f0b429;text-shadow:0 0 10px #f80;z-index:15;transition:all .5s ease-out;';
    const sp = pos.project(camera);
    el.style.left = ((sp.x * 0.5 + 0.5) * window.innerWidth) + 'px'; 
    el.style.top = ((1 - (sp.y * 0.5 + 0.5)) * window.innerHeight) + 'px';
    document.body.appendChild(el);
    setTimeout(() => { el.style.opacity = '0'; el.style.transform = 'translateY(-40px) scale(1.5)'; }, 50);
    setTimeout(() => { el.remove(); }, 600);
  }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME LOOP MANAGERS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
class GameLoopManager {
  constructor(sc) {
    this.sc = sc; 
    this.score = 0; 
    this.crimesStopped = 0;
    this.bpGeo = new THREE.BoxGeometry(3, 4, 2); 
    this.bpMat = new THREE.MeshStandardMaterial({color: 0x44ff44, emissive: 0x114411});
    this.bpMeshes = interactables.backpacks.map(pos => { 
      const m = new THREE.Mesh(this.bpGeo, this.bpMat); 
      m.position.copy(pos); 
      sc.add(m); 
      return m; 
    });
    this.activeCrime = null; 
    this.crimeSpawnCool = 5; 
    this.enemies = [];
    this.uiCrime = document.getElementById('crime-alert'); 
    this.uiCrimeTimer = document.getElementById('crime-timer'); 
    this.uiMarker = document.getElementById('crime-marker');
    Combat.init();
  }
  
  _spawnCrime(playerPos) {
    const angle = Math.random() * Math.PI * 2; 
    const dist = 80 + Math.random() * 100;
    const crimePos = new THREE.Vector3(playerPos.x + Math.cos(angle) * dist, 1, playerPos.z + Math.sin(angle) * dist);
    const newEnemies = [];
    
    for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
      const e = new Enemy(this.sc, crimePos.clone().add(new THREE.Vector3((Math.random() - 0.5) * 16, 0, (Math.random() - 0.5) * 16)));
      newEnemies.push(e); 
      this.enemies.push(e);
    }
    
    this.activeCrime = { pos: crimePos, enemies: newEnemies, timer: 90 };
    this.uiCrime.style.color = '#fff'; 
    this.uiCrime.style.display = 'block';
    this.uiCrime.innerHTML = 'üö® CRIME IN PROGRESS ‚Äî DEFEAT THE THUGS! <span id="crime-timer">90</span>s';
    this.uiMarker.style.display = 'block';
  }
  
  update(dt, playerPos, camera) {
    for (let i = this.bpMeshes.length - 1; i >= 0; i--) {
      const bp = this.bpMeshes[i]; 
      bp.rotation.y += dt;
      if (bp.position.distanceTo(playerPos) < 5) { 
        this.sc.remove(bp); 
        this.bpMeshes.splice(i, 1); 
        this.score++; 
        document.getElementById('collectibles-ui').innerText = "BACKPACKS: " + this.score; 
      }
    }
    
    if (!this.activeCrime) {
      this.crimeSpawnCool -= dt; 
      if (this.crimeSpawnCool <= 0) this._spawnCrime(playerPos);
    }
    
    if (this.activeCrime) {
      const c = this.activeCrime; 
      c.timer -= dt;
      const livingCount = c.enemies.filter(e => !e.dead).length;
      const nearEnemy = c.enemies.some(e => !e.dead && e.group.position.distanceTo(playerPos) < 12);
      
      if (nearEnemy) { 
        this.uiCrime.style.background = 'rgba(255,50,50,0.95)'; 
        this.uiCrime.innerHTML = `‚ö° FIGHT! PRESS M1 / SQUARE ‚Äî ${livingCount} left`; 
      } else { 
        this.uiCrime.style.background = 'rgba(230,36,41,0.85)'; 
        this.uiCrime.innerHTML = `üö® CRIME IN PROGRESS ‚Äî ${livingCount} left &nbsp; <b>${Math.ceil(c.timer)}s</b>`; 
      }
      
      const screenPos = c.pos.clone().project(camera);
      const inFrustum = screenPos.z < 1 && Math.abs(screenPos.x) < 1 && Math.abs(screenPos.y) < 1;
      this.uiMarker.style.left = (inFrustum ? (screenPos.x * 0.5 + 0.5) * window.innerWidth : Math.max(20, Math.min(window.innerWidth - 20, (screenPos.x * 0.5 + 0.5) * window.innerWidth))) + 'px';
      this.uiMarker.style.top = (inFrustum ? (1 - (screenPos.y * 0.5 + 0.5)) * window.innerHeight : Math.max(20, Math.min(window.innerHeight - 20, (1 - (screenPos.y * 0.5 + 0.5)) * window.innerHeight))) + 'px';
      this.uiMarker.style.display = 'block';
      
      if (livingCount === 0) this._crimeSuccess(); 
      else if (c.timer <= 0) this._crimeFail();
    }
    
    for (let i = this.enemies.length - 1; i >= 0; i--) { 
      const e = this.enemies[i]; 
      if (e.dead && e.group.parent === null) { 
        this.enemies.splice(i, 1); 
        continue; 
      } 
      e.update(dt, playerPos, camera); 
    }
    Combat.update(dt, playerPos, player.vel, this.enemies);
  }
  
  _crimeSuccess() {
    this.crimesStopped++; 
    this.uiCrime.style.background = 'rgba(20,180,20,0.85)'; 
    this.uiCrime.innerHTML = `‚úì CRIME STOPPED!`; 
    this.uiMarker.style.display = 'none';
    this.activeCrime = null; 
    this.crimeSpawnCool = 18 + Math.random() * 8; 
    setTimeout(() => { this.uiCrime.style.display = 'none'; }, 2500);
  }
  
  _crimeFail() {
    this.uiCrime.style.background = 'rgba(60,60,60,0.9)'; 
    this.uiCrime.style.color = '#f44'; 
    this.uiCrime.innerHTML = '‚úó CRIME FAILED'; 
    this.uiMarker.style.display = 'none';
    if (this.activeCrime) {
      this.activeCrime.enemies.forEach(e => { 
        if (!e.dead) { this.sc.remove(e.group); e.hpEl.remove(); e.dead = true; }
      });
    }
    this.activeCrime = null; 
    this.crimeSpawnCool = 14 + Math.random() * 8; 
    setTimeout(() => { this.uiCrime.style.display = 'none'; this.uiCrime.style.color = '#fff'; }, 2500);
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SWING CONTROLLER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
class SwingController {
  constructor(pos, vel, cam, sc, webLines, onStateChange) {
    this.pos = pos; 
    this.vel = vel; 
    this.cam = cam; 
    this.sc = sc; 
    this.webLines = webLines; 
    this.onStateChange = onStateChange;
    this.state = 'AIRBORNE'; 
    this.anchorPoint = new THREE.Vector3(); 
    this.ropeLength = 0; 
    this.currentHand = 'R'; 
    this.swingTimer = 0;
    this._pumpCooldown = 0; 
    this.zipTarget = new THREE.Vector3(); 
    this.zipGravTimer = 0;
    this._downRay = new THREE.Raycaster(); 
    this._downRay.ray.direction.set(0, -1, 0); 
    this._attachRay = new THREE.Raycaster();
    this._hapticCooldown = 0; 
    this._toAnchor = new THREE.Vector3();
  }
  
  update(dt) {
    this._hapticCooldown = Math.max(0, this._hapticCooldown - dt); 
    this._pumpCooldown = Math.max(0, this._pumpCooldown - dt);
    if (this.zipGravTimer > 0) this.zipGravTimer -= dt;
    
    switch (this.state) { 
      case 'AIRBORNE': this._updateAirborne(dt); break; 
      case 'SWINGING': this._updateSwinging(dt); break; 
      case 'ZIPPING': this._updateZipping(dt); break; 
    }
  }
  
  get gravityDisabled() { 
    return this.state === 'ZIPPING' && this.zipGravTimer > 0; 
  }
  
  _enterAirborne() { 
    this.state = 'AIRBORNE'; 
    this._hideWebLines(); 
    this.onStateChange('AIRBORNE'); 
  }
  
  _enterSwinging(anchor, ropeLen) {
    this.anchorPoint.copy(anchor); 
    this.ropeLength = ropeLen; 
    this.swingTimer = 0; 
    this.state = 'SWINGING';
    
    const horizSpd = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z);
    if (horizSpd < 8) { 
      const camDir = new THREE.Vector3(); 
      this.cam.getWorldDirection(camDir); 
      camDir.y = 0; 
      camDir.normalize(); 
      this.vel.addScaledVector(camDir, 18 - horizSpd); 
    }
    
    this._triggerHapticCatch(); 
    this.onStateChange('SWINGING');
  }
  
  _enterZipping(target) { 
    this.zipTarget.copy(target); 
    this.zipGravTimer = CFG.zipGravityTime; 
    this.vel.set(0, 0, 0); 
    this.state = 'ZIPPING'; 
    this._hideWebLines(); 
    this.onStateChange('ZIPPING'); 
  }
  
  _updateAirborne(dt) {
    if (Input.swing) { 
      if (this._swingBuffer === undefined) this._swingBuffer = 0; 
      this._swingBuffer = 0.30; 
    }
    if (this._swingBuffer === undefined) this._swingBuffer = 0;
    
    if (this._swingBuffer > 0) {
      this._swingBuffer -= dt; 
      const isFalling = this.vel.y < -8; 
      const a = this._tryAttach(isFalling);
      if (a) { 
        this._swingBuffer = 0; 
        this._enterSwinging(a.point, a.ropeLen); 
        return; 
      }
    }
    if (Input.zip) { 
      const hit = this._getAimHit(); 
      if (hit && hit.point.y > this.pos.y + 5) { 
        this._enterZipping(hit.point.clone().addScaledVector(new THREE.Vector3(0, 1, 0), 2)); 
        return; 
      } 
    }
  }
  
  _updateSwinging(dt) {
    this.swingTimer += dt;
    if (!Input.swing || Input.jump) { 
      this._releaseSwing(Input.jump); 
      return; 
    }
    if (Input.zip) { 
      const hit = this._getAimHit(); 
      if (hit && hit.point.y > this.pos.y + 5) { 
        this._releaseSwing(false); 
        this._enterZipping(hit.point.clone().addScaledVector(new THREE.Vector3(0, 1, 0), 2)); 
        return; 
      } 
    }
    
    const rising = this.vel.y > 4; 
    const timeout = this.swingTimer > 1.4;
    if ((rising || timeout) && this._pumpCooldown <= 0) { 
      const next = this._tryAttach(); 
      if (next) { 
        this._pumpCooldown = 0.35; 
        this._enterSwinging(next.point, next.ropeLen); 
        return; 
      } 
    }
    
    this._groundBuffer(dt); 
    this._applyPendulum(dt);
    
    if (Input.move.x !== 0 || Input.move.y !== 0) {
      const sy2 = Input.look.x; 
      const sFwdX = Math.sin(sy2), sFwdZ = Math.cos(sy2); 
      const sRtX = sFwdZ, sRtZ = -sFwdX;
      
      // Increased the input boost when holding forward to give a better sense of speed
      if (Input.move.y < -0.1) { 
        const fwdBoost = CFG.swingBoost * 2.5 * dt * Math.abs(Input.move.y); 
        this.vel.x += sFwdX * fwdBoost; 
        this.vel.z += sFwdZ * fwdBoost; 
      }
      if (Math.abs(Input.move.x) > 0.1) { 
        const sideBoost = CFG.swingBoost * 0.8 * dt * Input.move.x; 
        this.vel.x += sRtX * sideBoost; 
        this.vel.z += sRtZ * sideBoost; 
      }
    }
    
    const spd = this.vel.length(); 
    if (spd > CFG.swingMaxSpeed) {
      this.vel.multiplyScalar(CFG.swingMaxSpeed / spd);
    }
    this._drawWebLine();
  }
  
  _updateZipping(dt) {
    const dir = new THREE.Vector3().subVectors(this.zipTarget, this.pos); 
    const dist = dir.length();
    
    if (dist < 4) {
      this.pos.copy(this.zipTarget); 
      const camDir = new THREE.Vector3(); 
      this.cam.getWorldDirection(camDir); 
      camDir.y = 0; 
      camDir.normalize();
      
      this.vel.set(0, CFG.releaseBoost * 1.4, 0); 
      this.vel.addScaledVector(camDir, CFG.slingBoost); 
      this._enterAirborne();
    } else { 
      this.pos.addScaledVector(dir.normalize(), CFG.zipSpeed * dt); 
    }
  }
  
  _applyPendulum(dt) {
    this._toAnchor.subVectors(this.anchorPoint, this.pos); 
    const dist = this._toAnchor.length();
    if (dist < 0.001 || dist < this.ropeLength) return;
    
    const dir = this._toAnchor.clone().multiplyScalar(1 / dist);
    
    // Enforce rope length constraint securely
    for (let iter = 0; iter < 3; iter++) { 
      this._toAnchor.subVectors(this.anchorPoint, this.pos); 
      const d2 = this._toAnchor.length(); 
      if (d2 <= this.ropeLength) break; 
      const excess = d2 - this.ropeLength; 
      this.pos.addScaledVector(dir, excess * 0.95); 
    }
    
    const radialVel = this.vel.dot(dir); 
    
    // THIS IS THE BIG PHYSICS FIX:
    // If we are pulling against the web, redirect that momentum into speed instead of killing it.
    if (radialVel < 0) { 
      this.vel.addScaledVector(dir, -radialVel); 
      
      // If swinging downward, apply a momentum multiplier (gravity assist)
      if (this.vel.y < 0) {
        this.vel.multiplyScalar(1.008); // Speed up on the downswing!
      }
    }
    
    // Less drag than before to maintain high speeds
    this.vel.multiplyScalar(0.9995);
  }
  
  _groundBuffer(dt) {
    this._downRay.ray.origin.copy(this.pos); 
    const hits = this._downRay.intersectObjects(cityColliders);
    const groundDist = Math.min(hits.length ? hits[0].distance : Infinity, this.pos.y);
    
    if (groundDist < CFG.groundBuffer) {
      this.ropeLength = Math.max(5, this.ropeLength - CFG.webShortenRate * dt);
      if (this.vel.y < 0) { 
        const total = this.vel.length(); 
        const hDir = new THREE.Vector3(this.vel.x, 0, this.vel.z).normalize(); 
        this.vel.copy(hDir.multiplyScalar(total * 0.92)); 
        this.vel.y = Math.max(this.vel.y, 0); 
      }
    }
  }
  
  _tryAttach(assist=false) {
    const yaw = Input.look.x; 
    const fwdX = Math.sin(yaw); 
    const fwdZ = Math.cos(yaw);
    const velSpd = this.vel.length(); 
    let bx = fwdX, bz = fwdZ;
    
    if (velSpd > 2) { 
      const vx = this.vel.x / velSpd, vz = this.vel.z / velSpd; 
      bx = fwdX * 0.65 + vx * 0.35; 
      bz = fwdZ * 0.65 + vz * 0.35; 
      const bl = Math.sqrt(bx*bx + bz*bz); 
      if (bl > 0) { bx /= bl; bz /= bl; } 
    }
    
    const handSign = this.currentHand === 'R' ? 1 : -1; 
    const isFalling = this.vel.y < -8; 
    const range = (assist || isFalling) ? CFG.swingRange * 1.4 : CFG.swingRange * 1.1; 
    const minHeight = (assist || isFalling) ? 2 : 6;
    
    const offsets = [ 
      [0, 0.70], [0, 0.45], [handSign*0.25, 0.60], [-handSign*0.25, 0.60], 
      [handSign*0.50, 0.45], [-handSign*0.50, 0.45], [handSign*0.25, 0.90], 
      [-handSign*0.25, 0.90], [0, 1.00] 
    ];
    
    if (assist || isFalling) { 
      offsets.push([handSign*0.80, 0.55], [-handSign*0.80, 0.55], [handSign*1.10, 0.40], [-handSign*1.10, 0.40], [handSign*0.60, 0.80], [-handSign*0.60, 0.80], [0, 0.25]); 
    }
    
    let best = null;
    for (const [lat, vert] of offsets) {
      const rtX = fwdZ, rtZ = -fwdX; 
      const dx = bx + rtX * lat; 
      const dy = vert; 
      const dz = bz + rtZ * lat;
      const len = Math.sqrt(dx*dx + dy*dy + dz*dz); 
      const dir = new THREE.Vector3(dx/len, dy/len, dz/len);
      
      this._attachRay.set(this.pos, dir); 
      this._attachRay.far = range; 
      const hits = this._attachRay.intersectObjects(cityColliders);
      
      if (!hits.length || hits[0].point.y < this.pos.y + minHeight) continue;
      
      const hit = hits[0]; 
      const score = hit.point.y;
      if (!best || score > best.score) {
        best = { point: hit.point.clone(), ropeLen: this.pos.distanceTo(hit.point) * 0.95, score };
      }
    }
    
    if (best) { 
      this.currentHand = this.currentHand === 'R' ? 'L' : 'R'; 
      return { point: best.point, ropeLen: best.ropeLen }; 
    }
    return null;
  }
  
  _releaseSwing(jump) {
    if (jump) { 
      this.vel.y += CFG.releaseBoost; 
      const fwdSpd = new THREE.Vector3(this.vel.x, 0, this.vel.z).length(); 
      if (fwdSpd > 30) this.vel.multiplyScalar(1.20); // Extra release jump momentum 
    }
    this._enterAirborne();
  }
  
  _getAimHit() { 
    const camDir = new THREE.Vector3(); 
    this.cam.getWorldDirection(camDir); 
    this._attachRay.set(this.cam.position, camDir); 
    this._attachRay.far = CFG.swingRange * 1.5; 
    const hits = this._attachRay.intersectObjects(cityColliders); 
    return hits.length ? hits[0] : null; 
  }
  
  _drawWebLine() {
    const hand = this.currentHand === 'R' ? 'R' : 'L'; 
    const activeLine = this.webLines[hand]; 
    const otherLine = this.webLines[hand === 'R' ? 'L' : 'R'];
    
    activeLine.visible = true; 
    otherLine.visible = false;
    
    const segs = this.webLines.segs; 
    const shoulderX = hand === 'R' ? 0.45 : -0.45; 
    const wrist = new THREE.Vector3(this.pos.x + shoulderX, this.pos.y + 0.6, this.pos.z);
    
    const anchor = this.anchorPoint; 
    const mid = wrist.clone().lerp(anchor, 0.5); 
    const sagAmt = Math.min(this.ropeLength * 0.12, 18); 
    const ctrl = mid.clone().add(new THREE.Vector3(0, -sagAmt, 0));
    
    const pos = activeLine.geometry.attributes.position;
    for (let i = 0; i <= segs; i++) { 
      const t = i / segs; 
      const mt = 1 - t; 
      const x = mt*mt*wrist.x + 2*mt*t*ctrl.x + t*t*anchor.x; 
      const y = mt*mt*wrist.y + 2*mt*t*ctrl.y + t*t*anchor.y; 
      const z = mt*mt*wrist.z + 2*mt*t*ctrl.z + t*t*anchor.z; 
      pos.setXYZ(i, x, y, z); 
    }
    pos.needsUpdate = true; 
    activeLine.geometry.computeBoundingSphere();
  }
  
  _hideWebLines() { 
    this.webLines.R.visible = false; 
    this.webLines.L.visible = false; 
  }
  
  _triggerHapticCatch() {
    if (this._hapticCooldown > 0) return; 
    const gp = navigator.getGamepads ? navigator.getGamepads()[Input.gpIdx||0] : null;
    if (gp && gp.vibrationActuator) { 
      gp.vibrationActuator.playEffect('dual-rumble', { startDelay:0, duration:120, weakMagnitude:0.3, strongMagnitude:0.9 }).catch(()=>{}); 
      this._hapticCooldown = 0.5; 
    }
    if (!gp) { 
      const fl = document.getElementById('zip-flash'); 
      fl.style.background = '#c00'; 
      fl.style.opacity = 0.12; 
      setTimeout(() => { fl.style.opacity = 0; fl.style.background = '#fff'; }, 100); 
    }
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ANIMATION CONTROLLER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
class AnimController {
  constructor() {
    this.mixer   = null;   // THREE.AnimationMixer ‚Äî set once GLB loads
    this.clips   = {};     // name ‚Üí AnimationClip
    this.current = null;   // currently playing AnimationAction
    this.currentName = ''; // name of current clip
  }

  /** Register all clips from the GLB. We try to map by common naming conventions
   *  then fall back to index-based slots so any rig works. */
  loadClips(mixer, animations) {
    this.mixer = mixer;

    // Soft name ‚Üí canonical slot mapping (covers mixamo / various exporters)
    const slotMap = {
      idle:    ['idle','Idle','IDLE','bind','Bind','TPose','tpose','T-Pose'],
      run:     ['run','Run','RUN','running','Running','sprint','Sprint'],
      walk:    ['walk','Walk','WALK','walking','Walking'],
      jump:    ['jump','Jump','JUMP','jumpStart','JumpStart','fall','Fall'],
      fall:    ['fall','Fall','inAir','InAir','airborne','Airborne','Falling'],
      swing:   ['swing','Swing','SWING','swinging','Swinging','hang','Hang'],
      glide:   ['glide','Glide','GLIDE','webWings','WebWings','soar','Soar'],
      dive:    ['dive','Dive','DIVE','diving','Diving','plunge','Plunge'],
      attack:  ['attack','Attack','ATTACK','punch','Punch','hit','Hit','combo','Combo'],
      wallRun: ['wallrun','wallRun','WallRun','wall_run','wallclimb','WallClimb'],
      trick:   ['trick','Trick','TRICK','flip','Flip','spin','Spin','aerial','Aerial'],
      land:    ['land','Land','landing','Landing','LAND'],
    };

    // First pass: match by name
    for (const [slot, candidates] of Object.entries(slotMap)) {
      for (const clip of animations) {
        if (candidates.some(c => clip.name.toLowerCase().includes(c.toLowerCase()))) {
          if (!this.clips[slot]) this.clips[slot] = clip;
        }
      }
    }

    // Second pass: fill remaining slots by clip index order
    const fallbackOrder = ['idle','run','jump','fall','swing','attack','glide','dive','wallRun','trick','land','walk'];
    animations.forEach((clip, i) => {
      const slot = fallbackOrder[i];
      if (slot && !this.clips[slot]) this.clips[slot] = clip;
    });

    // Final fallback: if we still have no idle, use the first clip for everything
    if (!this.clips.idle && animations.length > 0) {
      fallbackOrder.forEach(s => { if (!this.clips[s]) this.clips[s] = animations[0]; });
    }

    console.log('[AnimCtrl] Loaded clips:', Object.entries(this.clips).map(([k,v])=>`${k}:${v.name}`).join(', '));
  }

  /** Crossfade to a named slot (if it exists and isn't already playing). */
  play(name, crossFade = 0.25) {
    if (!this.mixer || !this.clips[name]) return;
    if (this.currentName === name) return;

    const nextAction = this.mixer.clipAction(this.clips[name]);
    nextAction.reset().setEffectiveWeight(1).setEffectiveTimeScale(1);

    if (this.current && this.current !== nextAction) {
      nextAction.crossFadeFrom(this.current, crossFade, true);
    }
    nextAction.play();

    this.current = nextAction;
    this.currentName = name;
  }

  /** Called every frame with dt seconds. */
  update(dt) {
    if (this.mixer) this.mixer.update(dt);
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PLAYER CONTROLLER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
class Player {
  constructor(sc, cam) {
    this.sc = sc; 
    this.cam = cam; 
    this.pos = new THREE.Vector3(0, 2, 10); 
    this.vel = new THREE.Vector3(); 
    this.state = SS.GROUND; 
    this.mesh = new THREE.Group();
    this.anim = new AnimController();
    this._modelLoaded = false;

    // ‚îÄ‚îÄ Fallback capsule (visible until GLB loads) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    this._fallbackMesh = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.6, 1.8),
      new THREE.MeshStandardMaterial({ color: 0xe62429 })
    );
    this._fallbackMesh.castShadow = true;
    this.mesh.add(this._fallbackMesh);
    sc.add(this.mesh);

    // ‚îÄ‚îÄ Load the Spider-Man GLB ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // The GLB file must be in the same directory as this HTML.
    // GitHub Pages / local server will serve it automatically.
    const loader = new GLTFLoader();
    loader.load(
      'spiderman_classic_textured_rigged.glb',
      (gltf) => {
        // Remove fallback
        this.mesh.remove(this._fallbackMesh);
        this._fallbackMesh.geometry.dispose();

        const model = gltf.scene;

        // Auto-scale: measure bounding box and scale so height ‚âà 2.0 units
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);
        const desiredHeight = 2.0;
        const scale = desiredHeight / (size.y || 1);
        model.scale.setScalar(scale);

        // Re-centre at feet so position.y=0 means "standing on ground"
        box.setFromObject(model);
        const center = new THREE.Vector3();
        box.getCenter(center);
        model.position.set(-center.x, -box.min.y, -center.z);

        model.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });

        this.mesh.add(model);
        this._modelLoaded = true;

        // Set up animation mixer
        if (gltf.animations && gltf.animations.length > 0) {
          const mixer = new THREE.AnimationMixer(model);
          this.anim.loadClips(mixer, gltf.animations);
          this.anim.play('idle', 0);
        }
      },
      undefined,
      (err) => {
        // GLB failed to load (e.g. opened as file:// without a server).
        // Keep the fallback capsule so the game still works.
        console.warn('[Player] GLB load failed, using fallback mesh:', err.message || err);
      }
    );
    
    this.trickSpin = new THREE.Vector3(); 
    this.isTricking = false; 
    this.aimHit = null;
    this.isGliding = false; 
    this._prevTriangle = false;
    this.isChargingSlingshot = false; 
    this.slingshotCharge = 0; 
    this._prevAimJump = false;
    this.isLooping = false; 
    this.loopTimer = 0; 
    this.loopVelSave = new THREE.Vector3();
    this.landingTimer = 0; 
    this.isDiving = false;
    
    this.isWallRunning = false; 
    this.isWallClimbing = false; 
    this.wallNormal = new THREE.Vector3(); 
    this.wallRunTimer = 0; 
    this.wallRunDir = new THREE.Vector3(); 
    this._wallRay = new THREE.Raycaster();
    
    const WEB_SEGS = 12;
    const mkWebLine = (color) => { 
      const pts = []; 
      for (let i = 0; i <= WEB_SEGS; i++) pts.push(new THREE.Vector3()); 
      const geo = new THREE.BufferGeometry().setFromPoints(pts); 
      geo.attributes.position.usage = THREE.DynamicDrawUsage; 
      const mat = new THREE.LineBasicMaterial({ color, linewidth: 2, depthTest: false, transparent: true, opacity: 0.92 }); 
      const line = new THREE.Line(geo, mat); 
      line.renderOrder = 999; 
      line.visible = false; 
      return line; 
    };
    
    this.webLineR = mkWebLine(0xddddff); 
    this.webLineL = mkWebLine(0xddddff); 
    this.WEB_SEGS = WEB_SEGS; 
    sc.add(this.webLineR); 
    sc.add(this.webLineL);
    
    this.swing = new SwingController(this.pos, this.vel, cam, sc, { R: this.webLineR, L: this.webLineL, segs: this.WEB_SEGS }, (s) => this._onSwingState(s));
    
    this.ray = new THREE.Raycaster(); 
    this.camRay = new THREE.Raycaster(); 
    this.camFOV = 70; 
    this.camBank = 0; 
    this.camShakeTime = 0; 
    this.camGndRay = new THREE.Raycaster(); 
    this.camGndRay.ray.direction.set(0, -1, 0);
    
    this.ui = { 
      badge: document.getElementById('state-badge'), 
      spd: document.getElementById('speed-val'), 
      mom: document.getElementById('momentum-bar'), 
      aim: document.getElementById('aim-info'), 
      ring: document.getElementById('r-ring'), 
      zip: document.getElementById('zip-prompt'), 
      trick: document.getElementById('trick-prompt'), 
      flash: document.getElementById('zip-flash'), 
      ovl: document.getElementById('speed-overlay'), 
      speedLines: document.getElementById('speed-lines') 
    };
  }
  
  _onSwingState(s) {
    const map = { AIRBORNE: 'FALL', SWINGING: 'SWING', ZIPPING: 'ZIP' }; 
    this.state = map[s] || s;
    if (s !== 'SWINGING') { 
      this.ui.flash.style.opacity = s === 'ZIPPING' ? 0.4 : 0; 
    } 
    setTimeout(() => { 
      if (this.ui.flash) this.ui.flash.style.opacity = 0; 
    }, 120);
  }
  
  update(dt) {
    if (this.landingTimer > 0) {
      this.landingTimer -= dt;
      if (Input.jumpPressed && this.landingTimer > 0) { 
        this.vel.y += CFG.pointLaunchBoost; 
        const fwd = new THREE.Vector3(); 
        this.cam.getWorldDirection(fwd); 
        fwd.y = 0; 
        fwd.normalize(); 
        this.vel.addScaledVector(fwd, CFG.slingBoost * 0.8); 
        this.landingTimer = 0; 
        this.state = SS.FALL; 
        const fl = document.getElementById('zip-flash'); 
        fl.style.background = '#4af'; 
        fl.style.opacity = 0.18; 
        setTimeout(() => { fl.style.opacity = 0; fl.style.background = '#fff'; }, 120); 
      }
    }
    
    if (this.state === SS.GROUND) { 
      this._doGround(dt); 
    } else if (this.state === SS.WALLRUN) { 
      this._doWallRun(dt); 
    } else if (this.state === SS.WALLCLIMB) { 
      this._doWallClimb(dt); 
    } else if (this.isLooping) { 
      this._doLoop(dt); 
    } else if (this.isGliding) { 
      this._doGlide(dt); 
    } else if (this.isDiving) { 
      this._doDive(dt); 
    } else if (this.isTricking) { 
      this._doTrick(dt); 
    } else { 
      this.swing.update(dt); 
      this._checkWallContact(dt); 
    }
    
    if (!this.swing.gravityDisabled && !this.isLooping) {
      if (this.isGliding) { 
        this.vel.y += CFG.gravity * CFG.wingGravityScale * dt; 
        const horizSpd = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z); 
        this.vel.y += horizSpd * CFG.wingLiftFactor * dt * CFG.wingGravityScale; 
      } else if (this.isDiving) { 
        this.vel.y += CFG.gravity * CFG.diveGravScale * dt; 
      } else { 
        this.vel.y += CFG.gravity * dt; 
      }
    }
    
    const drag = this.state === SS.GROUND ? 0.9 : this.isGliding ? CFG.wingDrag : CFG.airFriction; 
    this.vel.x *= drag; 
    this.vel.z *= drag;
    
    if (this.state !== SS.ZIP && !this.isLooping) {
      const spd = this.vel.length();
      if (spd > 8) { 
        this.ray.set(this.pos, this.vel.clone().normalize()); 
        this.ray.far = spd * dt + 1; 
        const hits = this.ray.intersectObjects(cityColliders); 
        if (hits.length) { 
          this.pos.copy(hits[0].point).add(hits[0].face.normal.clone().multiplyScalar(0.5)); 
          this.vel.reflect(hits[0].face.normal).multiplyScalar(0.3); 
          if (this.isDiving) { 
            this.isDiving = false; 
            this.state = SS.GROUND; 
          } 
        } 
      }
      this.pos.addScaledVector(this.vel, dt);
    }
    
    if (this.pos.y < 1) { 
      this.pos.y = 1; 
      this.vel.y = 0; 
      if (this.state !== SS.GROUND) { 
        this._land(); 
      } 
    }
    
    if (this.state !== SS.GROUND && !this.isLooping && this.vel.y <= 0) { 
      this.ray.set(this.pos, new THREE.Vector3(0, -1, 0)); 
      this.ray.far = 2.0; 
      const roofHits = this.ray.intersectObjects(cityColliders); 
      if (roofHits.length > 0) { 
        this.pos.y = roofHits[0].point.y + 1.0; 
        this.vel.y = 0; 
        this._land(); 
      } 
    }
    
    if (this.state === SS.GROUND) { 
      this.ray.set(this.pos, new THREE.Vector3(0, -1, 0)); 
      this.ray.far = 2.5; 
      const floorCheck = this.ray.intersectObjects(cityColliders); 
      if (!floorCheck.length && this.pos.y > 2) { 
        this.state = SS.FALL; 
        this.isDiving = false; 
      } 
    }
    
    this._updateAim(); 
    this._updateMesh(dt); 
    this._updateCamera(dt); 
    this._updateUI();
  }
  
  _land() { 
    const wasAirborne = this.state !== SS.GROUND; 
    this.state = SS.GROUND; 
    this.isGliding = false; 
    this.isDiving = false; 
    this.isLooping = false; 
    this.isWallRunning = false; 
    this.isWallClimbing = false; 
    this.mesh.rotation.set(0, 0, 0); 
    this.swing._enterAirborne(); 
    if (wasAirborne) { 
      this.landingTimer = CFG.pointLaunchWindow; 
    } 
  }
  
  _doGround(dt) {
    const yaw = Input.look.x; 
    const fwdX = Math.sin(yaw); 
    const fwdZ = Math.cos(yaw); 
    const rtX = fwdZ; 
    const rtZ = -fwdX; 
    const mx = Input.move.x; 
    const mz = Input.move.y;
    
    if (mx * mx + mz * mz > 0.0001) { 
      let wdx = fwdX * (-mz) + rtX * mx; 
      let wdz = fwdZ * (-mz) + rtZ * mx; 
      const len = Math.sqrt(wdx * wdx + wdz * wdz); 
      if (len > 0) { wdx /= len; wdz /= len; } 
      
      this.vel.x += wdx * CFG.runAccel * dt; 
      this.vel.z += wdz * CFG.runAccel * dt; 
      
      const hspd = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z); 
      if (hspd > CFG.maxGround) { 
        this.vel.x = (this.vel.x / hspd) * CFG.maxGround; 
        this.vel.z = (this.vel.z / hspd) * CFG.maxGround; 
      } 
    }
    
    const aimJumpHeld = Input.aim && Input.jump;
    if (aimJumpHeld && !this.isChargingSlingshot) { 
      this.isChargingSlingshot = true; 
      this.slingshotCharge = 0; 
    }
    
    if (this.isChargingSlingshot) {
      if (aimJumpHeld) { 
        this.slingshotCharge = Math.min(1.0, this.slingshotCharge + dt / CFG.slingshotChargeMax); 
        this.vel.x *= 0.85; 
        this.vel.z *= 0.85; 
        this.ui.badge.textContent = 'CHARGING ' + Math.round(this.slingshotCharge * 100) + '%'; 
      } else { 
        const power = this.slingshotCharge * CFG.slingshotPower; 
        const sy = Input.look.x; 
        const launchDir = new THREE.Vector3(Math.sin(sy), 0, Math.cos(sy)); 
        this.vel.copy(launchDir.multiplyScalar(power)); 
        this.vel.y = power * 0.55; 
        this.slingshotCharge = 0; 
        this.isChargingSlingshot = false; 
        this.state = SS.FALL; 
        const fl = document.getElementById('zip-flash'); 
        fl.style.background = '#fa0'; 
        fl.style.opacity = 0.22; 
        setTimeout(() => { fl.style.opacity = 0; fl.style.background = '#fff'; }, 160); 
        return; 
      } 
      return;
    }
    
    if (Input.jump && !Input.aim) { 
      this.vel.y = CFG.jumpPower; 
      this.state = SS.FALL; 
    }
    if (Input.dive) { 
      this.state = SS.FALL; 
      this.isDiving = true; 
    }
    if (Input.swing && !Input.aim) { 
      const attached = this.swing._tryAttach(); 
      if (attached) { 
        this.swing._enterSwinging(attached.point, attached.ropeLen); 
      } 
    }
  }
  
  _doTrick(dt) {
    if (!Input.trick || this.pos.y < 5) { 
      if (this.trickSpin.lengthSq() > 1) this.vel.multiplyScalar(1.2); 
      this.isTricking = false; 
      this.state = SS.FALL; 
      this.mesh.rotation.set(0, 0, 0); 
      this.ui.trick.style.display = 'none'; 
      return; 
    }
    this.trickSpin.x += Input.move.y * 10 * dt; 
    this.trickSpin.z -= Input.move.x * 10 * dt; 
    this.mesh.rotation.x += this.trickSpin.x * dt; 
    this.mesh.rotation.z += this.trickSpin.z * dt; 
    this.vel.y -= CFG.gravity * 0.3 * dt;
  }
  
  _doGlide(dt) {
    const triEdge = Input.triangle && !this._prevTriangle; 
    this._prevTriangle = Input.triangle;
    if (triEdge || Input.swing) { 
      this.isGliding = false; 
      this.state = SS.FALL; 
      return; 
    }
    const gy = Input.look.x; 
    const gFwdX = Math.sin(gy), gFwdZ = Math.cos(gy); 
    const gRtX = gFwdZ, gRtZ = -gFwdX; 
    const glideDir = new THREE.Vector3( gFwdX * (-Input.move.y) + gRtX * Input.move.x, 0, gFwdZ * (-Input.move.y) + gRtZ * Input.move.x );
    if (glideDir.lengthSq() > 0) this.vel.addScaledVector(glideDir.normalize(), CFG.airAccel * dt);
    this.mesh.rotation.z = -Input.move.x * 0.4; 
    this.mesh.rotation.x = Input.move.y * 0.2;
  }
  
  _doDive(dt) {
    const diveDir = new THREE.Vector3(this.vel.x, -1, this.vel.z).normalize(); 
    this.vel.addScaledVector(diveDir, 60 * dt); 
    this.mesh.rotation.x = Math.PI * 0.45;
    const spd = this.vel.length(); 
    if (Input.swing && spd > CFG.loopSpeedThreshold && !this.isLooping) { 
      this._startLoop(); 
      return; 
    }
    if (!Input.dive) { 
      this.isDiving = false; 
      this.state = SS.FALL; 
      this.mesh.rotation.x = 0; 
    }
  }
  
  _findWall(maxDist=1.4) {
    const camDir = new THREE.Vector3(); 
    this.cam.getWorldDirection(camDir); 
    camDir.y = 0; 
    camDir.normalize(); 
    const camSide = camDir.clone().cross(new THREE.Vector3(0, 1, 0)).normalize();
    const dirs = [ camDir, camSide.clone().negate(), camSide, camDir.clone().add(camSide.clone().negate()).normalize(), camDir.clone().add(camSide).normalize() ];
    
    for (const d of dirs) { 
      this._wallRay.set(this.pos, d); 
      this._wallRay.far = maxDist; 
      const hits = this._wallRay.intersectObjects(cityColliders); 
      if (hits.length) { 
        const n = hits[0].face.normal.clone().transformDirection(hits[0].object.matrixWorld).normalize(); 
        if (Math.abs(n.y) < 0.4) return { normal: n, point: hits[0].point }; 
      } 
    } 
    return null;
  }
  
  _checkWallContact(dt) {
    if (this.state === SS.GROUND || this.state === SS.WALLRUN || this.state === SS.WALLCLIMB) return; 
    if (this.swing.state === 'SWINGING' || this.swing.state === 'ZIPPING') return;
    
    const wall = this._findWall(1.5); 
    if (!wall) return;
    
    if (Input.swing) { 
      this.wallNormal.copy(wall.normal); 
      this._startWallClimb(); 
      return; 
    }
    const horizSpd = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z);
    if (Input.dodge && horizSpd > 10) { 
      this.wallNormal.copy(wall.normal); 
      this._startWallRun(); 
    }
  }
  
  _startWallRun() { 
    this.isWallRunning = true; 
    this.isWallClimbing = false; 
    this.state = SS.WALLRUN; 
    this.wallRunTimer = 0; 
    const vDotN = this.vel.dot(this.wallNormal); 
    if (vDotN < 0) this.vel.addScaledVector(this.wallNormal, -vDotN); 
    this.wallRunDir.copy(this.vel).setY(0).normalize(); 
  }
  
  _startWallClimb() { 
    this.isWallClimbing = true; 
    this.isWallRunning = false; 
    this.state = SS.WALLCLIMB; 
    this.vel.set(0, 10, 0); 
  }
  
  _doWallRun(dt) {
    this.wallRunTimer += dt; 
    const wall = this._findWall(2.0); 
    const exitFall = !wall || this.wallRunTimer > 2.2; 
    const jumpOff = Input.jumpPressed;
    
    if (exitFall || jumpOff || Input.swing) { 
      this.isWallRunning = false; 
      this.state = SS.FALL; 
      if (jumpOff) { 
        this.vel.addScaledVector(this.wallNormal, 28); 
        this.vel.y = CFG.jumpPower * 0.85; 
      } 
      this.mesh.rotation.z = 0; 
      return; 
    }
    
    const wry = Input.look.x; 
    const camFwdWR = new THREE.Vector3(Math.sin(wry), 0, Math.cos(wry)); 
    const runAccel = camFwdWR.clone(); 
    const aWallComp = runAccel.dot(this.wallNormal); 
    runAccel.addScaledVector(this.wallNormal, -aWallComp);
    
    if (runAccel.lengthSq() > 0.01 && Input.move.y < -0.1) { 
      this.vel.addScaledVector(runAccel.normalize(), CFG.runAccel * dt * Math.abs(Input.move.y)); 
    }
    
    this.vel.y -= (CFG.gravity * 0.08) * dt; 
    this.vel.y = Math.max(this.vel.y, -4);
    
    if (wall) { 
      const wallPenetration = this.wallNormal.dot(this.pos.clone().sub(wall.point)); 
      if (wallPenetration > 1.2) { 
        this.pos.addScaledVector(this.wallNormal, -(wallPenetration - 1.2)); 
      } 
    }
    
    const horizSpd = Math.sqrt(this.vel.x * this.vel.x + this.vel.z * this.vel.z); 
    if (horizSpd > CFG.maxGround * 1.4) { 
      const s = CFG.maxGround * 1.4 / horizSpd; 
      this.vel.x *= s; 
      this.vel.z *= s; 
    }
    const wallTilt = Math.min(this.wallRunTimer * 1.5, 0.35); 
    this.mesh.rotation.z = this.wallNormal.x > 0 ? wallTilt : -wallTilt; 
    this.mesh.rotation.x = -0.2;
  }
  
  _doWallClimb(dt) {
    const wall = this._findWall(2.0);
    if (!wall || !Input.swing || this.pos.y > 1200) { 
      this.isWallClimbing = false; 
      this.state = SS.FALL; 
      this.mesh.rotation.x = 0; 
      return; 
    }
    if (Input.jumpPressed) { 
      this.isWallClimbing = false; 
      this.state = SS.FALL; 
      this.vel.addScaledVector(this.wallNormal, 32); 
      this.vel.y = CFG.jumpPower; 
      this.mesh.rotation.x = 0; 
      return; 
    }
    const climbSpeed = 18 + (-Input.move.y) * 14; 
    this.vel.y = climbSpeed; 
    const wallAlong = new THREE.Vector3(0, 1, 0).cross(this.wallNormal).normalize(); 
    this.vel.x = wallAlong.x * Input.move.x * 10; 
    this.vel.z = wallAlong.z * Input.move.x * 10;
    
    if (wall) { 
      const penetration = this.wallNormal.dot(this.pos.clone().sub(wall.point)); 
      if (penetration > 1.1) this.pos.addScaledVector(this.wallNormal, -(penetration - 1.1)); 
    }
    this.mesh.rotation.x = 0.5;
  }
  
  _startLoop() { 
    this.isLooping = true; 
    this.loopTimer = 0; 
    this.isDiving = false; 
    this.loopVelSave.copy(this.vel); 
    this.loopVelSave.y = Math.abs(this.loopVelSave.y); 
  }
  
  _doLoop(dt) {
    this.loopTimer += dt; 
    const t = this.loopTimer / CFG.loopDuration; 
    const theta = t * Math.PI * 2; 
    const horizSpd = Math.sqrt(this.loopVelSave.x * this.loopVelSave.x + this.loopVelSave.z * this.loopVelSave.z);
    
    this.vel.y = Math.sin(theta) * horizSpd * 1.2; 
    const fwd = new THREE.Vector3(this.loopVelSave.x, 0, this.loopVelSave.z).normalize(); 
    this.vel.x = fwd.x * horizSpd; 
    this.vel.z = fwd.z * horizSpd; 
    this.pos.addScaledVector(this.vel, dt); 
    this.mesh.rotation.x = theta;
    
    if (t >= 1.0) { 
      this.isLooping = false; 
      this.isDiving = false; 
      this.mesh.rotation.set(0, 0, 0); 
      this.vel.multiplyScalar(CFG.loopBoost); 
      this.state = SS.FALL; 
      const fl = document.getElementById('zip-flash'); 
      fl.style.background = '#f4f'; 
      fl.style.opacity = 0.2; 
      setTimeout(() => { fl.style.opacity = 0; fl.style.background = '#fff'; }, 200); 
    }
  }
  
  _updateAim() {
    const camDir = new THREE.Vector3(); 
    this.cam.getWorldDirection(camDir); 
    this.ray.set(this.cam.position, camDir); 
    this.ray.far = CFG.swingRange * 1.5; 
    const hits = this.ray.intersectObjects(cityColliders); 
    this.aimHit = hits.length ? hits[0] : null;
    
    this.swing._lastAimHit = this.aimHit; 
    const cached = this.aimHit; 
    this.swing._getAimHit = () => cached;
    
    const isAirborne = this.state !== SS.GROUND; 
    const triEdge = Input.triangle && !this._prevTriangle; 
    this._prevTriangle = Input.triangle;
    
    if (triEdge) { 
      if (isAirborne && !this.isTricking && !this.isLooping) { 
        if (this.isGliding) { 
          this.isGliding = false; 
          this.state = SS.FALL; 
        } else { 
          this.isGliding = true; 
          this.isDiving = false; 
          this.state = SS.FALL; 
        } 
      } 
    }
    
    if (Input.dive && isAirborne && !this.isDiving && !this.isLooping && !this.isGliding) { 
      this.isDiving = true; 
      this.isGliding = false; 
    }
    
    if (Input.trick && this.vel.y < 0 && this.state === SS.FALL && !this.isTricking && !this.isDiving && !this.isGliding) { 
      this.isTricking = true; 
      this.state = SS.TRICK; 
      this.trickSpin.set(0, 0, 0); 
      this.ui.trick.style.display = 'block'; 
    }
  }
  
  _updateMesh(dt) { 
    this.mesh.position.copy(this.pos); 
    if (!this.isTricking && this.vel.lengthSq() > 1) { 
      this.mesh.rotation.y = Math.atan2(this.vel.x, this.vel.z); 
    }

    // ‚îÄ‚îÄ Drive animations based on game state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    this.anim.update(dt);

    const swingState = this.swing.state;
    const spd = Math.sqrt(this.vel.x*this.vel.x + this.vel.z*this.vel.z);

    let animName;
    if (this.isLooping) {
      animName = 'trick';
    } else if (this.isTricking) {
      animName = 'trick';
    } else if (this.isGliding) {
      animName = 'glide';
    } else if (this.isDiving) {
      animName = 'dive';
    } else if (swingState === 'SWINGING' || swingState === 'ZIPPING') {
      animName = 'swing';
    } else if (this.state === SS.WALLRUN) {
      animName = 'wallRun';
    } else if (this.state === SS.WALLCLIMB) {
      animName = 'wallRun';
    } else if (this.state === SS.GROUND) {
      // On the ground: idle vs walk vs run
      animName = spd < 2 ? 'idle' : spd < 18 ? 'walk' : 'run';
    } else {
      // Airborne (FALL / FALL after jump)
      animName = this.vel.y > 4 ? 'jump' : 'fall';
    }

    // Only switch if the clip exists (fallback stays on whatever played last)
    if (this.anim.clips[animName]) {
      this.anim.play(animName, 0.20);
    }
  }
  
  _updateCamera(dt) {
    const scState = this.swing.state; 
    const isSwinging = scState === 'SWINGING'; 
    const isDiving = this.isDiving || this.isLooping; 
    const isGround = this.state === SS.GROUND; 
    const spd = this.vel.length();
    
    let targetFOV = isGround ? 70 : isDiving ? 115 : isSwinging ? THREE.MathUtils.lerp(72, CFG.camFOVmax, Math.min(spd / CFG.swingMaxSpeed, 1)) : 75;
    this.camFOV = THREE.MathUtils.lerp(this.camFOV, targetFOV, Math.min(dt * 5, 1)); 
    this.cam.fov = this.camFOV; 
    this.cam.updateProjectionMatrix();
    
    const YAW = Input.look.x; 
    const PITCH = Input.look.y;
    let armH, armV; 
    if (isGround) { armH = 5.5; armV = 2.5; } 
    else if (isSwinging) { armH = 7.0; armV = 3.2; } 
    else if (isDiving) { armH = 3.5; armV = 1.2; } 
    else { armH = 6.0; armV = 2.8; }
    
    const cosP = Math.cos(PITCH); 
    const sinP = Math.sin(PITCH); 
    const cosY = Math.cos(YAW); 
    const sinY = Math.sin(YAW);
    
    const idealCamPos = new THREE.Vector3( 
      this.pos.x - sinY * cosP * armH, 
      this.pos.y + sinP * armH * 0.6 + armV, 
      this.pos.z - cosY * cosP * armH 
    );
    
    const velHoriz = new THREE.Vector3(this.vel.x, 0, this.vel.z); 
    const lookAheadScale = isSwinging ? 0.04 : 0.015;
    const focusPos = new THREE.Vector3( 
      this.pos.x + velHoriz.x * lookAheadScale, 
      this.pos.y + 1.8, 
      this.pos.z + velHoriz.z * lookAheadScale 
    );
    
    const smoothing = isGround ? 0.008 : isSwinging ? 0.022 : isDiving ? 0.006 : 0.012; 
    const lerpT = 1.0 - Math.pow(smoothing, dt);
    this.cam.position.lerp(idealCamPos, Math.min(lerpT, 0.98));
    
    const toPlayer = new THREE.Vector3().subVectors(this.cam.position, focusPos); 
    const tpLen = toPlayer.length();
    
    if (tpLen > 0.5) { 
      this.camRay.set(focusPos, toPlayer.clone().normalize()); 
      this.camRay.far = tpLen + 0.8; 
      const hits = this.camRay.intersectObjects(cityColliders); 
      if (hits.length && hits[0].distance < tpLen) { 
        this.cam.position.copy( hits[0].point.clone().addScaledVector(toPlayer.clone().normalize(), -CFG.camCollisionPad) ); 
      } 
    }
    
    if (this.cam.position.y < this.pos.y + 0.5) this.cam.position.y = this.pos.y + 0.5;
    
    if (isDiving) { 
      this.camShakeTime += dt * 12; 
      const amp = CFG.camShakeAmp * Math.min(spd / 80, 1); 
      this.cam.position.x += Math.sin(this.camShakeTime * 1.7) * amp * 0.5; 
      this.cam.position.y += Math.sin(this.camShakeTime * 2.3) * amp * 0.3; 
    } else { 
      this.camShakeTime = 0; 
    }
    
    if (!this._smoothFocus) this._smoothFocus = focusPos.clone(); 
    this._smoothFocus.lerp(focusPos, Math.min(1.0 - Math.pow(0.005, dt), 0.95)); 
    this.cam.lookAt(this._smoothFocus);
    
    if (isSwinging) { 
      const camFwdB = new THREE.Vector3(); 
      this.cam.getWorldDirection(camFwdB); 
      camFwdB.y = 0; 
      camFwdB.normalize(); 
      const camRtB = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), camFwdB); 
      const lateralSpd = this.vel.dot(camRtB); 
      const targetBank = -lateralSpd / CFG.swingMaxSpeed * CFG.camBankMax; 
      this.camBank = THREE.MathUtils.lerp(this.camBank, targetBank, dt * 4); 
    } else { 
      this.camBank = THREE.MathUtils.lerp(this.camBank, 0, dt * 8); 
    }
    
    if (Math.abs(this.camBank) > 0.0005) { 
      const bankQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.camBank); 
      this.cam.quaternion.multiply(bankQ); 
    }
    
    const spdRatio = spd / CFG.swingMaxSpeed; 
    this.ui.ovl.style.opacity = spdRatio > 0.5 ? Math.min((spdRatio - 0.5) * 1.6, 0.85).toString() : '0';
    if (this.ui.speedLines) { 
      this.ui.speedLines.style.opacity = isDiving ? Math.min(spd / 60, 1) * 0.9 : '0'; 
    }
  }
  
  _updateUI() {
    const spd = this.vel.length(); 
    this.ui.spd.textContent = (spd * 2.2).toFixed(0) + " mph"; 
    this.ui.mom.style.width = Math.min(spd / CFG.swingMaxSpeed * 100, 100) + "%";
    
    const scState = this.swing.state; 
    let displayState = this.isChargingSlingshot ? 'SLINGSHOT ' + Math.round(this.slingshotCharge * 100) + '%' : 
                       this.isLooping ? 'LOOP-DE-LOOP' : 
                       this.isGliding ? 'WEB WINGS' : 
                       this.isDiving ? 'DIVING' : 
                       this.state === SS.WALLRUN ? 'WALL RUN' : 
                       this.state === SS.WALLCLIMB ? 'WALL CLIMB' : 
                       this.isTricking ? 'TRICK' : 
                       this.state === SS.GROUND ? 'GROUND' : 
                       this.landingTimer > 0 ? 'LAUNCH!' : scState;
                       
    this.ui.badge.textContent = displayState; 
    this.ui.badge.className = "state-badge " + (scState === 'SWINGING' ? 'swinging' : (this.isTricking || this.isLooping) ? 'trick' : this.isGliding ? 'swinging' : '');
    
    const canZip = this.aimHit && this.aimHit.point.y > this.pos.y + 5; 
    this.ui.aim.textContent = canZip ? "ZIP POINT" : (this.isGliding ? "GLIDING" : ""); 
    this.ui.ring.style.borderColor = this.isGliding ? '#fa0' : canZip ? "#4f4" : (scState === 'SWINGING' ? '#4af' : '#fff'); 
    this.ui.zip.style.display = canZip ? "block" : "none"; 
    this.ui.ring.style.opacity = 0.4 + Input.gripValue * 0.6;
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê MAIN LOOP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true }); 
  renderer.setSize(window.innerWidth, window.innerHeight); 
  renderer.shadowMap.enabled = true; 
  document.body.appendChild(renderer.domElement);
  
  scene = new THREE.Scene(); 
  scene.background = new THREE.Color(0x88ccff); 
  scene.fog = new THREE.FogExp2(0x88ccff, 0.0010);
  
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 6000);
  clock = new THREE.Clock();
  
  const sun = new THREE.DirectionalLight(0xffffff, 1.5); 
  sun.position.set(500, 1000, 500); 
  sun.castShadow = true; 
  sun.shadow.camera.top = sun.shadow.camera.right = 2500; 
  sun.shadow.camera.bottom = sun.shadow.camera.left = -2500; 
  sun.shadow.mapSize.set(2048, 2048); 
  scene.add(sun); 
  scene.add(new THREE.AmbientLight(0x404040));
  
  createCity(scene); 
  player = new Player(scene, camera); 
  gameLoop = new GameLoopManager(scene);
  
  document.addEventListener('keydown', e => Keys[e.code] = true); 
  document.addEventListener('keyup', e => Keys[e.code] = false); 
  document.addEventListener('mousedown', e => { if (e.button === 0) Keys['Mouse0'] = true; }); 
  document.addEventListener('mouseup', e => { if (e.button === 0) Keys['Mouse0'] = false; }); 
  window.addEventListener('gamepadconnected', e => Input.gpIdx = e.gamepad.index);
  
  renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());
  
  document.getElementById('btn-newgame').addEventListener('click', () => { 
    document.getElementById('start-screen').style.display = 'none'; 
    document.getElementById('hud').style.display = 'flex'; 
    document.getElementById('lock-msg').style.display = 'block'; 
    gameState = 'PLAY'; 
    clock.start(); 
  });
  
  document.addEventListener('mousemove', e => { 
    if (document.pointerLockElement) { 
      Input.look.x -= e.movementX * 0.0022; 
      Input.look.y -= e.movementY * 0.0018; 
      Input.look.y = Math.max(-Math.PI * 0.42, Math.min(Math.PI * 0.42, Input.look.y)); 
    } 
  });
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  animate();
}

function togglePause() { 
  if (gameState === 'MENU') return; 
  gameState = gameState === 'PLAY' ? 'PAUSE' : 'PLAY'; 
  document.getElementById('pause-screen').style.display = gameState === 'PAUSE' ? 'flex' : 'none'; 
  if (gameState === 'PAUSE') document.exitPointerLock(); 
}

function animate() { 
  requestAnimationFrame(animate); 
  const dt = Math.min(clock.getDelta(), 0.1); 
  if (gameState === 'PLAY') { 
    pollInput(dt); 
    player.update(dt); 
    gameLoop.update(dt, player.pos, camera); 
  } 
  renderer.render(scene, camera); 
}

init();
</script>
</body>
</html>